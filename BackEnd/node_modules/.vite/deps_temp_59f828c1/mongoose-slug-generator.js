import {
  __commonJS
} from "./chunk-CQXHTUV2.js";

// node_modules/speakingurl/lib/speakingurl.js
var require_speakingurl = __commonJS({
  "node_modules/speakingurl/lib/speakingurl.js"(exports, module) {
    (function(root, undefined2) {
      "use strict";
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"];
        var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","];
        var markChars = [".", "!", "~", "*", "'", "(", ")"];
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars;
        var charMap = {
          // latin
          "À": "A",
          "Á": "A",
          "Â": "A",
          "Ã": "A",
          "Ä": "Ae",
          "Å": "A",
          "Æ": "AE",
          "Ç": "C",
          "È": "E",
          "É": "E",
          "Ê": "E",
          "Ë": "E",
          "Ì": "I",
          "Í": "I",
          "Î": "I",
          "Ï": "I",
          "Ð": "D",
          "Ñ": "N",
          "Ò": "O",
          "Ó": "O",
          "Ô": "O",
          "Õ": "O",
          "Ö": "Oe",
          "Ő": "O",
          "Ø": "O",
          "Ù": "U",
          "Ú": "U",
          "Û": "U",
          "Ü": "Ue",
          "Ű": "U",
          "Ý": "Y",
          "Þ": "TH",
          "ß": "ss",
          "à": "a",
          "á": "a",
          "â": "a",
          "ã": "a",
          "ä": "ae",
          "å": "a",
          "æ": "ae",
          "ç": "c",
          "è": "e",
          "é": "e",
          "ê": "e",
          "ë": "e",
          "ì": "i",
          "í": "i",
          "î": "i",
          "ï": "i",
          "ð": "d",
          "ñ": "n",
          "ò": "o",
          "ó": "o",
          "ô": "o",
          "õ": "o",
          "ö": "oe",
          "ő": "o",
          "ø": "o",
          "ù": "u",
          "ú": "u",
          "û": "u",
          "ü": "ue",
          "ű": "u",
          "ý": "y",
          "þ": "th",
          "ÿ": "y",
          "ẞ": "SS",
          // language specific
          // Arabic
          "ا": "a",
          "أ": "a",
          "إ": "i",
          "آ": "aa",
          "ؤ": "u",
          "ئ": "e",
          "ء": "a",
          "ب": "b",
          "ت": "t",
          "ث": "th",
          "ج": "j",
          "ح": "h",
          "خ": "kh",
          "د": "d",
          "ذ": "th",
          "ر": "r",
          "ز": "z",
          "س": "s",
          "ش": "sh",
          "ص": "s",
          "ض": "dh",
          "ط": "t",
          "ظ": "z",
          "ع": "a",
          "غ": "gh",
          "ف": "f",
          "ق": "q",
          "ك": "k",
          "ل": "l",
          "م": "m",
          "ن": "n",
          "ه": "h",
          "و": "w",
          "ي": "y",
          "ى": "a",
          "ة": "h",
          "ﻻ": "la",
          "ﻷ": "laa",
          "ﻹ": "lai",
          "ﻵ": "laa",
          // Arabic diactrics
          "َ": "a",
          "ً": "an",
          "ِ": "e",
          "ٍ": "en",
          "ُ": "u",
          "ٌ": "on",
          "ْ": "",
          // Arabic numbers
          "٠": "0",
          "١": "1",
          "٢": "2",
          "٣": "3",
          "٤": "4",
          "٥": "5",
          "٦": "6",
          "٧": "7",
          "٨": "8",
          "٩": "9",
          // Burmese consonants
          "က": "k",
          "ခ": "kh",
          "ဂ": "g",
          "ဃ": "ga",
          "င": "ng",
          "စ": "s",
          "ဆ": "sa",
          "ဇ": "z",
          "စျ": "za",
          "ည": "ny",
          "ဋ": "t",
          "ဌ": "ta",
          "ဍ": "d",
          "ဎ": "da",
          "ဏ": "na",
          "တ": "t",
          "ထ": "ta",
          "ဒ": "d",
          "ဓ": "da",
          "န": "n",
          "ပ": "p",
          "ဖ": "pa",
          "ဗ": "b",
          "ဘ": "ba",
          "မ": "m",
          "ယ": "y",
          "ရ": "ya",
          "လ": "l",
          "ဝ": "w",
          "သ": "th",
          "ဟ": "h",
          "ဠ": "la",
          "အ": "a",
          // consonant character combos
          "ြ": "y",
          "ျ": "ya",
          "ွ": "w",
          "ြွ": "yw",
          "ျွ": "ywa",
          "ှ": "h",
          // independent vowels
          "ဧ": "e",
          "၏": "-e",
          "ဣ": "i",
          "ဤ": "-i",
          "ဉ": "u",
          "ဦ": "-u",
          "ဩ": "aw",
          "သြော": "aw",
          "ဪ": "aw",
          // numbers
          "၀": "0",
          "၁": "1",
          "၂": "2",
          "၃": "3",
          "၄": "4",
          "၅": "5",
          "၆": "6",
          "၇": "7",
          "၈": "8",
          "၉": "9",
          // virama and tone marks which are silent in transliteration
          "္": "",
          "့": "",
          "း": "",
          // Czech
          "č": "c",
          "ď": "d",
          "ě": "e",
          "ň": "n",
          "ř": "r",
          "š": "s",
          "ť": "t",
          "ů": "u",
          "ž": "z",
          "Č": "C",
          "Ď": "D",
          "Ě": "E",
          "Ň": "N",
          "Ř": "R",
          "Š": "S",
          "Ť": "T",
          "Ů": "U",
          "Ž": "Z",
          // Dhivehi
          "ހ": "h",
          "ށ": "sh",
          "ނ": "n",
          "ރ": "r",
          "ބ": "b",
          "ޅ": "lh",
          "ކ": "k",
          "އ": "a",
          "ވ": "v",
          "މ": "m",
          "ފ": "f",
          "ދ": "dh",
          "ތ": "th",
          "ލ": "l",
          "ގ": "g",
          "ޏ": "gn",
          "ސ": "s",
          "ޑ": "d",
          "ޒ": "z",
          "ޓ": "t",
          "ޔ": "y",
          "ޕ": "p",
          "ޖ": "j",
          "ޗ": "ch",
          "ޘ": "tt",
          "ޙ": "hh",
          "ޚ": "kh",
          "ޛ": "th",
          "ޜ": "z",
          "ޝ": "sh",
          "ޞ": "s",
          "ޟ": "d",
          "ޠ": "t",
          "ޡ": "z",
          "ޢ": "a",
          "ޣ": "gh",
          "ޤ": "q",
          "ޥ": "w",
          "ަ": "a",
          "ާ": "aa",
          "ި": "i",
          "ީ": "ee",
          "ު": "u",
          "ޫ": "oo",
          "ެ": "e",
          "ޭ": "ey",
          "ޮ": "o",
          "ޯ": "oa",
          "ް": "",
          // Greek
          "α": "a",
          "β": "v",
          "γ": "g",
          "δ": "d",
          "ε": "e",
          "ζ": "z",
          "η": "i",
          "θ": "th",
          "ι": "i",
          "κ": "k",
          "λ": "l",
          "μ": "m",
          "ν": "n",
          "ξ": "ks",
          "ο": "o",
          "π": "p",
          "ρ": "r",
          "σ": "s",
          "τ": "t",
          "υ": "y",
          "φ": "f",
          "χ": "x",
          "ψ": "ps",
          "ω": "o",
          "ά": "a",
          "έ": "e",
          "ί": "i",
          "ό": "o",
          "ύ": "y",
          "ή": "i",
          "ώ": "o",
          "ς": "s",
          "ϊ": "i",
          "ΰ": "y",
          "ϋ": "y",
          "ΐ": "i",
          "Α": "A",
          "Β": "B",
          "Γ": "G",
          "Δ": "D",
          "Ε": "E",
          "Ζ": "Z",
          "Η": "I",
          "Θ": "TH",
          "Ι": "I",
          "Κ": "K",
          "Λ": "L",
          "Μ": "M",
          "Ν": "N",
          "Ξ": "KS",
          "Ο": "O",
          "Π": "P",
          "Ρ": "R",
          "Σ": "S",
          "Τ": "T",
          "Υ": "Y",
          "Φ": "F",
          "Χ": "X",
          "Ψ": "PS",
          "Ω": "W",
          "Ά": "A",
          "Έ": "E",
          "Ί": "I",
          "Ό": "O",
          "Ύ": "Y",
          "Ή": "I",
          "Ώ": "O",
          "Ϊ": "I",
          "Ϋ": "Y",
          // Latvian
          "ā": "a",
          // 'č': 'c', // duplicate
          "ē": "e",
          "ģ": "g",
          "ī": "i",
          "ķ": "k",
          "ļ": "l",
          "ņ": "n",
          // 'š': 's', // duplicate
          "ū": "u",
          // 'ž': 'z', // duplicate
          "Ā": "A",
          // 'Č': 'C', // duplicate
          "Ē": "E",
          "Ģ": "G",
          "Ī": "I",
          "Ķ": "k",
          "Ļ": "L",
          "Ņ": "N",
          // 'Š': 'S', // duplicate
          "Ū": "U",
          // 'Ž': 'Z', // duplicate
          // Macedonian
          "Ќ": "Kj",
          "ќ": "kj",
          "Љ": "Lj",
          "љ": "lj",
          "Њ": "Nj",
          "њ": "nj",
          "Тс": "Ts",
          "тс": "ts",
          // Polish
          "ą": "a",
          "ć": "c",
          "ę": "e",
          "ł": "l",
          "ń": "n",
          // 'ó': 'o', // duplicate
          "ś": "s",
          "ź": "z",
          "ż": "z",
          "Ą": "A",
          "Ć": "C",
          "Ę": "E",
          "Ł": "L",
          "Ń": "N",
          "Ś": "S",
          "Ź": "Z",
          "Ż": "Z",
          // Ukranian
          "Є": "Ye",
          "І": "I",
          "Ї": "Yi",
          "Ґ": "G",
          "є": "ye",
          "і": "i",
          "ї": "yi",
          "ґ": "g",
          // Romanian
          "ă": "a",
          "Ă": "A",
          "ș": "s",
          "Ș": "S",
          // 'ş': 's', // duplicate
          // 'Ş': 'S', // duplicate
          "ț": "t",
          "Ț": "T",
          "ţ": "t",
          "Ţ": "T",
          // Russian
          "а": "a",
          "б": "b",
          "в": "v",
          "г": "g",
          "д": "d",
          "е": "e",
          "ё": "yo",
          "ж": "zh",
          "з": "z",
          "и": "i",
          "й": "j",
          "к": "k",
          "л": "l",
          "м": "m",
          "н": "n",
          "о": "o",
          "п": "p",
          "р": "r",
          "с": "s",
          "т": "t",
          "у": "u",
          "ф": "f",
          "х": "h",
          "ц": "c",
          "ч": "ch",
          "ш": "sh",
          "щ": "sh",
          "ъ": "",
          "ы": "y",
          "ь": "",
          "э": "e",
          "ю": "yu",
          "я": "ya",
          "А": "A",
          "Б": "B",
          "В": "V",
          "Г": "G",
          "Д": "D",
          "Е": "E",
          "Ё": "Yo",
          "Ж": "Zh",
          "З": "Z",
          "И": "I",
          "Й": "J",
          "К": "K",
          "Л": "L",
          "М": "M",
          "Н": "N",
          "О": "O",
          "П": "P",
          "Р": "R",
          "С": "S",
          "Т": "T",
          "У": "U",
          "Ф": "F",
          "Х": "H",
          "Ц": "C",
          "Ч": "Ch",
          "Ш": "Sh",
          "Щ": "Sh",
          "Ъ": "",
          "Ы": "Y",
          "Ь": "",
          "Э": "E",
          "Ю": "Yu",
          "Я": "Ya",
          // Serbian
          "ђ": "dj",
          "ј": "j",
          // 'љ': 'lj',  // duplicate
          // 'њ': 'nj', // duplicate
          "ћ": "c",
          "џ": "dz",
          "Ђ": "Dj",
          "Ј": "j",
          // 'Љ': 'Lj', // duplicate
          // 'Њ': 'Nj', // duplicate
          "Ћ": "C",
          "Џ": "Dz",
          // Slovak
          "ľ": "l",
          "ĺ": "l",
          "ŕ": "r",
          "Ľ": "L",
          "Ĺ": "L",
          "Ŕ": "R",
          // Turkish
          "ş": "s",
          "Ş": "S",
          "ı": "i",
          "İ": "I",
          // 'ç': 'c', // duplicate
          // 'Ç': 'C', // duplicate
          // 'ü': 'u', // duplicate, see langCharMap
          // 'Ü': 'U', // duplicate, see langCharMap
          // 'ö': 'o', // duplicate, see langCharMap
          // 'Ö': 'O', // duplicate, see langCharMap
          "ğ": "g",
          "Ğ": "G",
          // Vietnamese
          "ả": "a",
          "Ả": "A",
          "ẳ": "a",
          "Ẳ": "A",
          "ẩ": "a",
          "Ẩ": "A",
          "đ": "d",
          "Đ": "D",
          "ẹ": "e",
          "Ẹ": "E",
          "ẽ": "e",
          "Ẽ": "E",
          "ẻ": "e",
          "Ẻ": "E",
          "ế": "e",
          "Ế": "E",
          "ề": "e",
          "Ề": "E",
          "ệ": "e",
          "Ệ": "E",
          "ễ": "e",
          "Ễ": "E",
          "ể": "e",
          "Ể": "E",
          "ọ": "o",
          "Ọ": "o",
          "ố": "o",
          "Ố": "O",
          "ồ": "o",
          "Ồ": "O",
          "ổ": "o",
          "Ổ": "O",
          "ộ": "o",
          "Ộ": "O",
          "ỗ": "o",
          "Ỗ": "O",
          "ơ": "o",
          "Ơ": "O",
          "ớ": "o",
          "Ớ": "O",
          "ờ": "o",
          "Ờ": "O",
          "ợ": "o",
          "Ợ": "O",
          "ỡ": "o",
          "Ỡ": "O",
          "Ở": "o",
          "ở": "o",
          "ị": "i",
          "Ị": "I",
          "ĩ": "i",
          "Ĩ": "I",
          "ỉ": "i",
          "Ỉ": "i",
          "ủ": "u",
          "Ủ": "U",
          "ụ": "u",
          "Ụ": "U",
          "ũ": "u",
          "Ũ": "U",
          "ư": "u",
          "Ư": "U",
          "ứ": "u",
          "Ứ": "U",
          "ừ": "u",
          "Ừ": "U",
          "ự": "u",
          "Ự": "U",
          "ữ": "u",
          "Ữ": "U",
          "ử": "u",
          "Ử": "ư",
          "ỷ": "y",
          "Ỷ": "y",
          "ỳ": "y",
          "Ỳ": "Y",
          "ỵ": "y",
          "Ỵ": "Y",
          "ỹ": "y",
          "Ỹ": "Y",
          "ạ": "a",
          "Ạ": "A",
          "ấ": "a",
          "Ấ": "A",
          "ầ": "a",
          "Ầ": "A",
          "ậ": "a",
          "Ậ": "A",
          "ẫ": "a",
          "Ẫ": "A",
          // 'ă': 'a', // duplicate
          // 'Ă': 'A', // duplicate
          "ắ": "a",
          "Ắ": "A",
          "ằ": "a",
          "Ằ": "A",
          "ặ": "a",
          "Ặ": "A",
          "ẵ": "a",
          "Ẵ": "A",
          // symbols
          "“": '"',
          "”": '"',
          "‘": "'",
          "’": "'",
          "∂": "d",
          "ƒ": "f",
          "™": "(TM)",
          "©": "(C)",
          "œ": "oe",
          "Œ": "OE",
          "®": "(R)",
          "†": "+",
          "℠": "(SM)",
          "…": "...",
          "˚": "o",
          "º": "o",
          "ª": "a",
          "•": "*",
          "၊": ",",
          "။": ".",
          // currency
          "$": "USD",
          "€": "EUR",
          "₢": "BRN",
          "₣": "FRF",
          "£": "GBP",
          "₤": "ITL",
          "₦": "NGN",
          "₧": "ESP",
          "₩": "KRW",
          "₪": "ILS",
          "₫": "VND",
          "₭": "LAK",
          "₮": "MNT",
          "₯": "GRD",
          "₱": "ARS",
          "₲": "PYG",
          "₳": "ARA",
          "₴": "UAH",
          "₵": "GHS",
          "¢": "cent",
          "¥": "CNY",
          "元": "CNY",
          "円": "YEN",
          "﷼": "IRR",
          "₠": "EWE",
          "฿": "THB",
          "₨": "INR",
          "₹": "INR",
          "₰": "PF"
        };
        var lookAheadCharArray = [
          // burmese
          "်",
          // Dhivehi
          "ް"
        ];
        var diatricMap = {
          // Burmese
          // dependent vowels
          "ာ": "a",
          "ါ": "a",
          "ေ": "e",
          "ဲ": "e",
          "ိ": "i",
          "ီ": "i",
          "ို": "o",
          "ု": "u",
          "ူ": "u",
          "ေါင်": "aung",
          "ော": "aw",
          "ော်": "aw",
          "ေါ": "aw",
          "ေါ်": "aw",
          "်": "်",
          // this is special case but the character will be converted to latin in the code
          "က်": "et",
          "ိုက်": "aik",
          "ောက်": "auk",
          "င်": "in",
          "ိုင်": "aing",
          "ောင်": "aung",
          "စ်": "it",
          "ည်": "i",
          "တ်": "at",
          "ိတ်": "eik",
          "ုတ်": "ok",
          "ွတ်": "ut",
          "ေတ်": "it",
          "ဒ်": "d",
          "ိုဒ်": "ok",
          "ုဒ်": "ait",
          "န်": "an",
          "ာန်": "an",
          "ိန်": "ein",
          "ုန်": "on",
          "ွန်": "un",
          "ပ်": "at",
          "ိပ်": "eik",
          "ုပ်": "ok",
          "ွပ်": "ut",
          "န်ုပ်": "nub",
          "မ်": "an",
          "ိမ်": "ein",
          "ုမ်": "on",
          "ွမ်": "un",
          "ယ်": "e",
          "ိုလ်": "ol",
          "ဉ်": "in",
          "ံ": "an",
          "ိံ": "ein",
          "ုံ": "on",
          // Dhivehi
          "ައް": "ah",
          "ަށް": "ah"
        };
        var langCharMap = {
          "en": {},
          // default language
          "az": {
            // Azerbaijani
            "ç": "c",
            "ə": "e",
            "ğ": "g",
            "ı": "i",
            "ö": "o",
            "ş": "s",
            "ü": "u",
            "Ç": "C",
            "Ə": "E",
            "Ğ": "G",
            "İ": "I",
            "Ö": "O",
            "Ş": "S",
            "Ü": "U"
          },
          "cs": {
            // Czech
            "č": "c",
            "ď": "d",
            "ě": "e",
            "ň": "n",
            "ř": "r",
            "š": "s",
            "ť": "t",
            "ů": "u",
            "ž": "z",
            "Č": "C",
            "Ď": "D",
            "Ě": "E",
            "Ň": "N",
            "Ř": "R",
            "Š": "S",
            "Ť": "T",
            "Ů": "U",
            "Ž": "Z"
          },
          "fi": {
            // Finnish
            // 'å': 'a', duplicate see charMap/latin
            // 'Å': 'A', duplicate see charMap/latin
            "ä": "a",
            // ok
            "Ä": "A",
            // ok
            "ö": "o",
            // ok
            "Ö": "O"
            // ok
          },
          "hu": {
            // Hungarian
            "ä": "a",
            // ok
            "Ä": "A",
            // ok
            // 'á': 'a', duplicate see charMap/latin
            // 'Á': 'A', duplicate see charMap/latin
            "ö": "o",
            // ok
            "Ö": "O",
            // ok
            // 'ő': 'o', duplicate see charMap/latin
            // 'Ő': 'O', duplicate see charMap/latin
            "ü": "u",
            "Ü": "U",
            "ű": "u",
            "Ű": "U"
          },
          "lt": {
            // Lithuanian
            "ą": "a",
            "č": "c",
            "ę": "e",
            "ė": "e",
            "į": "i",
            "š": "s",
            "ų": "u",
            "ū": "u",
            "ž": "z",
            "Ą": "A",
            "Č": "C",
            "Ę": "E",
            "Ė": "E",
            "Į": "I",
            "Š": "S",
            "Ų": "U",
            "Ū": "U"
          },
          "lv": {
            // Latvian
            "ā": "a",
            "č": "c",
            "ē": "e",
            "ģ": "g",
            "ī": "i",
            "ķ": "k",
            "ļ": "l",
            "ņ": "n",
            "š": "s",
            "ū": "u",
            "ž": "z",
            "Ā": "A",
            "Č": "C",
            "Ē": "E",
            "Ģ": "G",
            "Ī": "i",
            "Ķ": "k",
            "Ļ": "L",
            "Ņ": "N",
            "Š": "S",
            "Ū": "u",
            "Ž": "Z"
          },
          "pl": {
            // Polish
            "ą": "a",
            "ć": "c",
            "ę": "e",
            "ł": "l",
            "ń": "n",
            "ó": "o",
            "ś": "s",
            "ź": "z",
            "ż": "z",
            "Ą": "A",
            "Ć": "C",
            "Ę": "e",
            "Ł": "L",
            "Ń": "N",
            "Ó": "O",
            "Ś": "S",
            "Ź": "Z",
            "Ż": "Z"
          },
          "sk": {
            // Slovak
            "ä": "a",
            "Ä": "A"
          },
          "sr": {
            // Serbian
            "љ": "lj",
            "њ": "nj",
            "Љ": "Lj",
            "Њ": "Nj",
            "đ": "dj",
            "Đ": "Dj"
          },
          "tr": {
            // Turkish
            "Ü": "U",
            "Ö": "O",
            "ü": "u",
            "ö": "o"
          }
        };
        var symbolMap = {
          "ar": {
            "∆": "delta",
            "∞": "la-nihaya",
            "♥": "hob",
            "&": "wa",
            "|": "aw",
            "<": "aqal-men",
            ">": "akbar-men",
            "∑": "majmou",
            "¤": "omla"
          },
          "az": {},
          "ca": {
            "∆": "delta",
            "∞": "infinit",
            "♥": "amor",
            "&": "i",
            "|": "o",
            "<": "menys que",
            ">": "mes que",
            "∑": "suma dels",
            "¤": "moneda"
          },
          "cz": {
            "∆": "delta",
            "∞": "nekonecno",
            "♥": "laska",
            "&": "a",
            "|": "nebo",
            "<": "mene jako",
            ">": "vice jako",
            "∑": "soucet",
            "¤": "mena"
          },
          "de": {
            "∆": "delta",
            "∞": "unendlich",
            "♥": "Liebe",
            "&": "und",
            "|": "oder",
            "<": "kleiner als",
            ">": "groesser als",
            "∑": "Summe von",
            "¤": "Waehrung"
          },
          "dv": {
            "∆": "delta",
            "∞": "kolunulaa",
            "♥": "loabi",
            "&": "aai",
            "|": "noonee",
            "<": "ah vure kuda",
            ">": "ah vure bodu",
            "∑": "jumula",
            "¤": "faisaa"
          },
          "en": {
            "∆": "delta",
            "∞": "infinity",
            "♥": "love",
            "&": "and",
            "|": "or",
            "<": "less than",
            ">": "greater than",
            "∑": "sum",
            "¤": "currency"
          },
          "es": {
            "∆": "delta",
            "∞": "infinito",
            "♥": "amor",
            "&": "y",
            "|": "u",
            "<": "menos que",
            ">": "mas que",
            "∑": "suma de los",
            "¤": "moneda"
          },
          "fr": {
            "∆": "delta",
            "∞": "infiniment",
            "♥": "Amour",
            "&": "et",
            "|": "ou",
            "<": "moins que",
            ">": "superieure a",
            "∑": "somme des",
            "¤": "monnaie"
          },
          "gr": {},
          "hu": {
            "∆": "delta",
            "∞": "vegtelen",
            "♥": "szerelem",
            "&": "es",
            "|": "vagy",
            "<": "kisebb mint",
            ">": "nagyobb mint",
            "∑": "szumma",
            "¤": "penznem"
          },
          "it": {
            "∆": "delta",
            "∞": "infinito",
            "♥": "amore",
            "&": "e",
            "|": "o",
            "<": "minore di",
            ">": "maggiore di",
            "∑": "somma",
            "¤": "moneta"
          },
          "lt": {},
          "lv": {
            "∆": "delta",
            "∞": "bezgaliba",
            "♥": "milestiba",
            "&": "un",
            "|": "vai",
            "<": "mazak neka",
            ">": "lielaks neka",
            "∑": "summa",
            "¤": "valuta"
          },
          "my": {
            "∆": "kwahkhyaet",
            "∞": "asaonasme",
            "♥": "akhyait",
            "&": "nhin",
            "|": "tho",
            "<": "ngethaw",
            ">": "kyithaw",
            "∑": "paungld",
            "¤": "ngwekye"
          },
          "mk": {},
          "nl": {
            "∆": "delta",
            "∞": "oneindig",
            "♥": "liefde",
            "&": "en",
            "|": "of",
            "<": "kleiner dan",
            ">": "groter dan",
            "∑": "som",
            "¤": "valuta"
          },
          "pl": {
            "∆": "delta",
            "∞": "nieskonczonosc",
            "♥": "milosc",
            "&": "i",
            "|": "lub",
            "<": "mniejsze niz",
            ">": "wieksze niz",
            "∑": "suma",
            "¤": "waluta"
          },
          "pt": {
            "∆": "delta",
            "∞": "infinito",
            "♥": "amor",
            "&": "e",
            "|": "ou",
            "<": "menor que",
            ">": "maior que",
            "∑": "soma",
            "¤": "moeda"
          },
          "ro": {
            "∆": "delta",
            "∞": "infinit",
            "♥": "dragoste",
            "&": "si",
            "|": "sau",
            "<": "mai mic ca",
            ">": "mai mare ca",
            "∑": "suma",
            "¤": "valuta"
          },
          "ru": {
            "∆": "delta",
            "∞": "beskonechno",
            "♥": "lubov",
            "&": "i",
            "|": "ili",
            "<": "menshe",
            ">": "bolshe",
            "∑": "summa",
            "¤": "valjuta"
          },
          "sk": {
            "∆": "delta",
            "∞": "nekonecno",
            "♥": "laska",
            "&": "a",
            "|": "alebo",
            "<": "menej ako",
            ">": "viac ako",
            "∑": "sucet",
            "¤": "mena"
          },
          "sr": {},
          "tr": {
            "∆": "delta",
            "∞": "sonsuzluk",
            "♥": "ask",
            "&": "ve",
            "|": "veya",
            "<": "kucuktur",
            ">": "buyuktur",
            "∑": "toplam",
            "¤": "para birimi"
          },
          "uk": {
            "∆": "delta",
            "∞": "bezkinechnist",
            "♥": "lubov",
            "&": "i",
            "|": "abo",
            "<": "menshe",
            ">": "bilshe",
            "∑": "suma",
            "¤": "valjuta"
          },
          "vn": {
            "∆": "delta",
            "∞": "vo cuc",
            "♥": "yeu",
            "&": "va",
            "|": "hoac",
            "<": "nho hon",
            ">": "lon hon",
            "∑": "tong",
            "¤": "tien te"
          }
        };
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars.join("");
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars.join("");
          }
          if (markFlag) {
            allowedChars += markChars.join("");
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v) {
            var r;
            if (v.length > 1) {
              r = new RegExp("\\b" + escapeChars(v) + "\\b", "gi");
            } else {
              r = new RegExp(escapeChars(v), "gi");
            }
            input = input.replace(r, customReplacements[v]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        if (titleCase) {
          input = input.replace(/(\w)(\S*)/g, function(_, i2, r) {
            var j = i2.toUpperCase() + (r !== null ? r : "");
            return Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0 ? j : j.toLowerCase();
          });
        }
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i = 0, l = input.length; i < l; i++) {
          ch = input[i];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i === l - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.join("").indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.join("").indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c in customReplacements) {
          if (customReplacements[c] === ch) {
            return true;
          }
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e) {
        }
      }
    })(exports);
  }
});

// node_modules/speakingurl/index.js
var require_speakingurl2 = __commonJS({
  "node_modules/speakingurl/index.js"(exports, module) {
    module.exports = require_speakingurl();
  }
});

// node_modules/shortid/lib/random/random-from-seed.js
var require_random_from_seed = __commonJS({
  "node_modules/shortid/lib/random/random-from-seed.js"(exports, module) {
    "use strict";
    var seed = 1;
    function getNextValue() {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    }
    function setSeed(_seed_) {
      seed = _seed_;
    }
    module.exports = {
      nextValue: getNextValue,
      seed: setSeed
    };
  }
});

// node_modules/shortid/lib/alphabet.js
var require_alphabet = __commonJS({
  "node_modules/shortid/lib/alphabet.js"(exports, module) {
    "use strict";
    var randomFromSeed = require_random_from_seed();
    var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
    var alphabet;
    var previousSeed;
    var shuffled;
    function reset() {
      shuffled = false;
    }
    function setCharacters(_alphabet_) {
      if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
          alphabet = ORIGINAL;
          reset();
        }
        return;
      }
      if (_alphabet_ === alphabet) {
        return;
      }
      if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
      }
      var unique = _alphabet_.split("").filter(function(item, ind, arr) {
        return ind !== arr.lastIndexOf(item);
      });
      if (unique.length) {
        throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
      }
      alphabet = _alphabet_;
      reset();
    }
    function characters(_alphabet_) {
      setCharacters(_alphabet_);
      return alphabet;
    }
    function setSeed(seed) {
      randomFromSeed.seed(seed);
      if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
      }
    }
    function shuffle() {
      if (!alphabet) {
        setCharacters(ORIGINAL);
      }
      var sourceArray = alphabet.split("");
      var targetArray = [];
      var r = randomFromSeed.nextValue();
      var characterIndex;
      while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
      }
      return targetArray.join("");
    }
    function getShuffled() {
      if (shuffled) {
        return shuffled;
      }
      shuffled = shuffle();
      return shuffled;
    }
    function lookup(index) {
      var alphabetShuffled = getShuffled();
      return alphabetShuffled[index];
    }
    function get() {
      return alphabet || ORIGINAL;
    }
    module.exports = {
      get,
      characters,
      seed: setSeed,
      lookup,
      shuffled: getShuffled
    };
  }
});

// node_modules/shortid/lib/random/random-byte-browser.js
var require_random_byte_browser = __commonJS({
  "node_modules/shortid/lib/random/random-byte-browser.js"(exports, module) {
    "use strict";
    var crypto = typeof window === "object" && (window.crypto || window.msCrypto);
    var randomByte;
    if (!crypto || !crypto.getRandomValues) {
      randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
          bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
      };
    } else {
      randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
      };
    }
    module.exports = randomByte;
  }
});

// node_modules/shortid/node_modules/nanoid/format.browser.js
var require_format_browser = __commonJS({
  "node_modules/shortid/node_modules/nanoid/format.browser.js"(exports, module) {
    module.exports = function(random, alphabet, size) {
      var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      var step = -~(1.6 * mask * size / alphabet.length);
      var id = "";
      while (true) {
        var bytes = random(step);
        var i = step;
        while (i--) {
          id += alphabet[bytes[i] & mask] || "";
          if (id.length === +size)
            return id;
        }
      }
    };
  }
});

// node_modules/shortid/lib/generate.js
var require_generate = __commonJS({
  "node_modules/shortid/lib/generate.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var random = require_random_byte_browser();
    var format = require_format_browser();
    function generate(number) {
      var loopCounter = 0;
      var done;
      var str = "";
      while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < Math.pow(16, loopCounter + 1);
        loopCounter++;
      }
      return str;
    }
    module.exports = generate;
  }
});

// node_modules/shortid/lib/build.js
var require_build = __commonJS({
  "node_modules/shortid/lib/build.js"(exports, module) {
    "use strict";
    var generate = require_generate();
    var alphabet = require_alphabet();
    var REDUCE_TIME = 1567752802062;
    var version = 7;
    var counter;
    var previousSeconds;
    function build(clusterWorkerId) {
      var str = "";
      var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
      if (seconds === previousSeconds) {
        counter++;
      } else {
        counter = 0;
        previousSeconds = seconds;
      }
      str = str + generate(version);
      str = str + generate(clusterWorkerId);
      if (counter > 0) {
        str = str + generate(counter);
      }
      str = str + generate(seconds);
      return str;
    }
    module.exports = build;
  }
});

// node_modules/shortid/lib/is-valid.js
var require_is_valid = __commonJS({
  "node_modules/shortid/lib/is-valid.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    function isShortId(id) {
      if (!id || typeof id !== "string" || id.length < 6) {
        return false;
      }
      var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
      return !nonAlphabetic.test(id);
    }
    module.exports = isShortId;
  }
});

// node_modules/shortid/lib/util/cluster-worker-id-browser.js
var require_cluster_worker_id_browser = __commonJS({
  "node_modules/shortid/lib/util/cluster-worker-id-browser.js"(exports, module) {
    "use strict";
    module.exports = 0;
  }
});

// node_modules/shortid/lib/index.js
var require_lib = __commonJS({
  "node_modules/shortid/lib/index.js"(exports, module) {
    "use strict";
    var alphabet = require_alphabet();
    var build = require_build();
    var isValid = require_is_valid();
    var clusterWorkerId = require_cluster_worker_id_browser() || 0;
    function seed(seedValue) {
      alphabet.seed(seedValue);
      return module.exports;
    }
    function worker(workerId) {
      clusterWorkerId = workerId;
      return module.exports;
    }
    function characters(newCharacters) {
      if (newCharacters !== void 0) {
        alphabet.characters(newCharacters);
      }
      return alphabet.shuffled();
    }
    function generate() {
      return build(clusterWorkerId);
    }
    module.exports = generate;
    module.exports.generate = generate;
    module.exports.seed = seed;
    module.exports.worker = worker;
    module.exports.characters = characters;
    module.exports.isValid = isValid;
  }
});

// node_modules/shortid/index.js
var require_shortid = __commonJS({
  "node_modules/shortid/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/async/lib/async.js
var require_async = __commonJS({
  "node_modules/async/lib/async.js"(exports, module) {
    (function() {
      var async = {};
      function noop() {
      }
      function identity(v) {
        return v;
      }
      function toBool(v) {
        return !!v;
      }
      function notId(v) {
        return !v;
      }
      var previous_async;
      var root = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || this;
      if (root != null) {
        previous_async = root.async;
      }
      async.noConflict = function() {
        root.async = previous_async;
        return async;
      };
      function only_once(fn) {
        return function() {
          if (fn === null)
            throw new Error("Callback was already called.");
          fn.apply(this, arguments);
          fn = null;
        };
      }
      function _once(fn) {
        return function() {
          if (fn === null)
            return;
          fn.apply(this, arguments);
          fn = null;
        };
      }
      var _toString = Object.prototype.toString;
      var _isArray = Array.isArray || function(obj) {
        return _toString.call(obj) === "[object Array]";
      };
      var _isObject = function(obj) {
        var type = typeof obj;
        return type === "function" || type === "object" && !!obj;
      };
      function _isArrayLike(arr) {
        return _isArray(arr) || // has a positive integer length property
        typeof arr.length === "number" && arr.length >= 0 && arr.length % 1 === 0;
      }
      function _arrayEach(arr, iterator) {
        var index = -1, length = arr.length;
        while (++index < length) {
          iterator(arr[index], index, arr);
        }
      }
      function _map(arr, iterator) {
        var index = -1, length = arr.length, result = Array(length);
        while (++index < length) {
          result[index] = iterator(arr[index], index, arr);
        }
        return result;
      }
      function _range(count) {
        return _map(Array(count), function(v, i) {
          return i;
        });
      }
      function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function(x, i, a) {
          memo = iterator(memo, x, i, a);
        });
        return memo;
      }
      function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function(key) {
          iterator(object[key], key);
        });
      }
      function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
          if (arr[i] === item)
            return i;
        }
        return -1;
      }
      var _keys = Object.keys || function(obj) {
        var keys = [];
        for (var k in obj) {
          if (obj.hasOwnProperty(k)) {
            keys.push(k);
          }
        }
        return keys;
      };
      function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
          len = coll.length;
          return function next() {
            i++;
            return i < len ? i : null;
          };
        } else {
          keys = _keys(coll);
          len = keys.length;
          return function next() {
            i++;
            return i < len ? keys[i] : null;
          };
        }
      }
      function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
          var length = Math.max(arguments.length - startIndex, 0);
          var rest = Array(length);
          for (var index = 0; index < length; index++) {
            rest[index] = arguments[index + startIndex];
          }
          switch (startIndex) {
            case 0:
              return func.call(this, rest);
            case 1:
              return func.call(this, arguments[0], rest);
          }
        };
      }
      function _withoutIndex(iterator) {
        return function(value, index, callback) {
          return iterator(value, callback);
        };
      }
      var _setImmediate = typeof setImmediate === "function" && setImmediate;
      var _delay = _setImmediate ? function(fn) {
        _setImmediate(fn);
      } : function(fn) {
        setTimeout(fn, 0);
      };
      if (typeof process === "object" && typeof process.nextTick === "function") {
        async.nextTick = process.nextTick;
      } else {
        async.nextTick = _delay;
      }
      async.setImmediate = _setImmediate ? _delay : async.nextTick;
      async.forEach = async.each = function(arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
      };
      async.forEachSeries = async.eachSeries = function(arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
      };
      async.forEachLimit = async.eachLimit = function(arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
      };
      async.forEachOf = async.eachOf = function(object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];
        var iter = _keyIterator(object);
        var key, completed = 0;
        while ((key = iter()) != null) {
          completed += 1;
          iterator(object[key], key, only_once(done));
        }
        if (completed === 0)
          callback(null);
        function done(err) {
          completed--;
          if (err) {
            callback(err);
          } else if (key === null && completed <= 0) {
            callback(null);
          }
        }
      };
      async.forEachOfSeries = async.eachOfSeries = function(obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
          var sync = true;
          if (key === null) {
            return callback(null);
          }
          iterator(obj[key], key, only_once(function(err) {
            if (err) {
              callback(err);
            } else {
              key = nextKey();
              if (key === null) {
                return callback(null);
              } else {
                if (sync) {
                  async.setImmediate(iterate);
                } else {
                  iterate();
                }
              }
            }
          }));
          sync = false;
        }
        iterate();
      };
      async.forEachOfLimit = async.eachOfLimit = function(obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
      };
      function _eachOfLimit(limit) {
        return function(obj, iterator, callback) {
          callback = _once(callback || noop);
          obj = obj || [];
          var nextKey = _keyIterator(obj);
          if (limit <= 0) {
            return callback(null);
          }
          var done = false;
          var running = 0;
          var errored = false;
          (function replenish() {
            if (done && running <= 0) {
              return callback(null);
            }
            while (running < limit && !errored) {
              var key = nextKey();
              if (key === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iterator(obj[key], key, only_once(function(err) {
                running -= 1;
                if (err) {
                  callback(err);
                  errored = true;
                } else {
                  replenish();
                }
              }));
            }
          })();
        };
      }
      function doParallel(fn) {
        return function(obj, iterator, callback) {
          return fn(async.eachOf, obj, iterator, callback);
        };
      }
      function doParallelLimit(fn) {
        return function(obj, limit, iterator, callback) {
          return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
      }
      function doSeries(fn) {
        return function(obj, iterator, callback) {
          return fn(async.eachOfSeries, obj, iterator, callback);
        };
      }
      function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function(value, index, callback2) {
          iterator(value, function(err, v) {
            results[index] = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      }
      async.map = doParallel(_asyncMap);
      async.mapSeries = doSeries(_asyncMap);
      async.mapLimit = doParallelLimit(_asyncMap);
      async.inject = async.foldl = async.reduce = function(arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function(x, i, callback2) {
          iterator(memo, x, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      };
      async.foldr = async.reduceRight = function(arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
      };
      async.transform = function(arr, memo, iterator, callback) {
        if (arguments.length === 3) {
          callback = iterator;
          iterator = memo;
          memo = _isArray(arr) ? [] : {};
        }
        async.eachOf(arr, function(v, k, cb) {
          iterator(memo, v, k, cb);
        }, function(err) {
          callback(err, memo);
        });
      };
      function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function(x, index, callback2) {
          iterator(x, function(v) {
            if (v) {
              results.push({ index, value: x });
            }
            callback2();
          });
        }, function() {
          callback(_map(results.sort(function(a, b) {
            return a.index - b.index;
          }), function(x) {
            return x.value;
          }));
        });
      }
      async.select = async.filter = doParallel(_filter);
      async.selectLimit = async.filterLimit = doParallelLimit(_filter);
      async.selectSeries = async.filterSeries = doSeries(_filter);
      function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
          iterator(value, function(v) {
            cb(!v);
          });
        }, callback);
      }
      async.reject = doParallel(_reject);
      async.rejectLimit = doParallelLimit(_reject);
      async.rejectSeries = doSeries(_reject);
      function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
          function done() {
            if (cb)
              cb(getResult(false, void 0));
          }
          function iteratee(x, _, callback) {
            if (!cb)
              return callback();
            iterator(x, function(v) {
              if (cb && check(v)) {
                cb(getResult(true, x));
                cb = iterator = false;
              }
              callback();
            });
          }
          if (arguments.length > 3) {
            eachfn(arr, limit, iteratee, done);
          } else {
            cb = iterator;
            iterator = limit;
            eachfn(arr, iteratee, done);
          }
        };
      }
      async.any = async.some = _createTester(async.eachOf, toBool, identity);
      async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
      async.all = async.every = _createTester(async.eachOf, notId, notId);
      async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
      function _findGetResult(v, x) {
        return x;
      }
      async.detect = _createTester(async.eachOf, identity, _findGetResult);
      async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
      async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
      async.sortBy = function(arr, iterator, callback) {
        async.map(arr, function(x, callback2) {
          iterator(x, function(err, criteria) {
            if (err) {
              callback2(err);
            } else {
              callback2(null, { value: x, criteria });
            }
          });
        }, function(err, results) {
          if (err) {
            return callback(err);
          } else {
            callback(null, _map(results.sort(comparator), function(x) {
              return x.value;
            }));
          }
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      };
      async.auto = function(tasks, concurrency, callback) {
        if (typeof arguments[1] === "function") {
          callback = concurrency;
          concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = remainingTasks;
        }
        var results = {};
        var runningTasks = 0;
        var hasError = false;
        var listeners = [];
        function addListener(fn) {
          listeners.unshift(fn);
        }
        function removeListener(fn) {
          var idx = _indexOf(listeners, fn);
          if (idx >= 0)
            listeners.splice(idx, 1);
        }
        function taskComplete() {
          remainingTasks--;
          _arrayEach(listeners.slice(0), function(fn) {
            fn();
          });
        }
        addListener(function() {
          if (!remainingTasks) {
            callback(null, results);
          }
        });
        _arrayEach(keys, function(k) {
          if (hasError)
            return;
          var task = _isArray(tasks[k]) ? tasks[k] : [tasks[k]];
          var taskCallback = _restParam(function(err, args) {
            runningTasks--;
            if (args.length <= 1) {
              args = args[0];
            }
            if (err) {
              var safeResults = {};
              _forEachOf(results, function(val, rkey) {
                safeResults[rkey] = val;
              });
              safeResults[k] = args;
              hasError = true;
              callback(err, safeResults);
            } else {
              results[k] = args;
              async.setImmediate(taskComplete);
            }
          });
          var requires = task.slice(0, task.length - 1);
          var len = requires.length;
          var dep;
          while (len--) {
            if (!(dep = tasks[requires[len]])) {
              throw new Error("Has nonexistent dependency in " + requires.join(", "));
            }
            if (_isArray(dep) && _indexOf(dep, k) >= 0) {
              throw new Error("Has cyclic dependencies");
            }
          }
          function ready() {
            return runningTasks < concurrency && _reduce(requires, function(a, x) {
              return a && results.hasOwnProperty(x);
            }, true) && !results.hasOwnProperty(k);
          }
          if (ready()) {
            runningTasks++;
            task[task.length - 1](taskCallback, results);
          } else {
            addListener(listener);
          }
          function listener() {
            if (ready()) {
              runningTasks++;
              removeListener(listener);
              task[task.length - 1](taskCallback, results);
            }
          }
        });
      };
      async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;
        var attempts = [];
        var opts = {
          times: DEFAULT_TIMES,
          interval: DEFAULT_INTERVAL
        };
        function parseTimes(acc, t) {
          if (typeof t === "number") {
            acc.times = parseInt(t, 10) || DEFAULT_TIMES;
          } else if (typeof t === "object") {
            acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
            acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
          } else {
            throw new Error("Unsupported argument type for 'times': " + typeof t);
          }
        }
        var length = arguments.length;
        if (length < 1 || length > 3) {
          throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)");
        } else if (length <= 2 && typeof times === "function") {
          callback = task;
          task = times;
        }
        if (typeof times !== "function") {
          parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;
        function wrappedTask(wrappedCallback, wrappedResults) {
          function retryAttempt(task2, finalAttempt2) {
            return function(seriesCallback) {
              task2(function(err, result) {
                seriesCallback(!err || finalAttempt2, { err, result });
              }, wrappedResults);
            };
          }
          function retryInterval(interval) {
            return function(seriesCallback) {
              setTimeout(function() {
                seriesCallback(null);
              }, interval);
            };
          }
          while (opts.times) {
            var finalAttempt = !(opts.times -= 1);
            attempts.push(retryAttempt(opts.task, finalAttempt));
            if (!finalAttempt && opts.interval > 0) {
              attempts.push(retryInterval(opts.interval));
            }
          }
          async.series(attempts, function(done, data) {
            data = data[data.length - 1];
            (wrappedCallback || opts.callback)(data.err, data.result);
          });
        }
        return opts.callback ? wrappedTask() : wrappedTask;
      };
      async.waterfall = function(tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
          var err = new Error("First argument to waterfall must be an array of functions");
          return callback(err);
        }
        if (!tasks.length) {
          return callback();
        }
        function wrapIterator(iterator) {
          return _restParam(function(err2, args) {
            if (err2) {
              callback.apply(null, [err2].concat(args));
            } else {
              var next = iterator.next();
              if (next) {
                args.push(wrapIterator(next));
              } else {
                args.push(callback);
              }
              ensureAsync(iterator).apply(null, args);
            }
          });
        }
        wrapIterator(async.iterator(tasks))();
      };
      function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};
        eachfn(tasks, function(task, key, callback2) {
          task(_restParam(function(err, args) {
            if (args.length <= 1) {
              args = args[0];
            }
            results[key] = args;
            callback2(err);
          }));
        }, function(err) {
          callback(err, results);
        });
      }
      async.parallel = function(tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
      };
      async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
      };
      async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
      };
      async.iterator = function(tasks) {
        function makeCallback(index) {
          function fn() {
            if (tasks.length) {
              tasks[index].apply(null, arguments);
            }
            return fn.next();
          }
          fn.next = function() {
            return index < tasks.length - 1 ? makeCallback(index + 1) : null;
          };
          return fn;
        }
        return makeCallback(0);
      };
      async.apply = _restParam(function(fn, args) {
        return _restParam(function(callArgs) {
          return fn.apply(
            null,
            args.concat(callArgs)
          );
        });
      });
      function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function(x, index, cb) {
          fn(x, function(err, y) {
            result = result.concat(y || []);
            cb(err);
          });
        }, function(err) {
          callback(err, result);
        });
      }
      async.concat = doParallel(_concat);
      async.concatSeries = doSeries(_concat);
      async.whilst = function(test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
          var next = _restParam(function(err, args) {
            if (err) {
              callback(err);
            } else if (test.apply(this, args)) {
              iterator(next);
            } else {
              callback.apply(null, [null].concat(args));
            }
          });
          iterator(next);
        } else {
          callback(null);
        }
      };
      async.doWhilst = function(iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
          return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
      };
      async.until = function(test, iterator, callback) {
        return async.whilst(function() {
          return !test.apply(this, arguments);
        }, iterator, callback);
      };
      async.doUntil = function(iterator, test, callback) {
        return async.doWhilst(iterator, function() {
          return !test.apply(this, arguments);
        }, callback);
      };
      async.during = function(test, iterator, callback) {
        callback = callback || noop;
        var next = _restParam(function(err, args) {
          if (err) {
            callback(err);
          } else {
            args.push(check);
            test.apply(this, args);
          }
        });
        var check = function(err, truth) {
          if (err) {
            callback(err);
          } else if (truth) {
            iterator(next);
          } else {
            callback(null);
          }
        };
        test(check);
      };
      async.doDuring = function(iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
          if (calls++ < 1) {
            next(null, true);
          } else {
            test.apply(this, arguments);
          }
        }, iterator, callback);
      };
      function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new Error("Concurrency must not be zero");
        }
        function _insert(q2, data, pos, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q2.started = true;
          if (!_isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q2.idle()) {
            return async.setImmediate(function() {
              q2.drain();
            });
          }
          _arrayEach(data, function(task) {
            var item = {
              data: task,
              callback: callback || noop
            };
            if (pos) {
              q2.tasks.unshift(item);
            } else {
              q2.tasks.push(item);
            }
            if (q2.tasks.length === q2.concurrency) {
              q2.saturated();
            }
          });
          async.setImmediate(q2.process);
        }
        function _next(q2, tasks) {
          return function() {
            workers -= 1;
            var removed = false;
            var args = arguments;
            _arrayEach(tasks, function(task) {
              _arrayEach(workersList, function(worker2, index) {
                if (worker2 === task && !removed) {
                  workersList.splice(index, 1);
                  removed = true;
                }
              });
              task.callback.apply(task, args);
            });
            if (q2.tasks.length + workers === 0) {
              q2.drain();
            }
            q2.process();
          };
        }
        var workers = 0;
        var workersList = [];
        var q = {
          tasks: [],
          concurrency,
          payload,
          saturated: noop,
          empty: noop,
          drain: noop,
          started: false,
          paused: false,
          push: function(data, callback) {
            _insert(q, data, false, callback);
          },
          kill: function() {
            q.drain = noop;
            q.tasks = [];
          },
          unshift: function(data, callback) {
            _insert(q, data, true, callback);
          },
          process: function() {
            while (!q.paused && workers < q.concurrency && q.tasks.length) {
              var tasks = q.payload ? q.tasks.splice(0, q.payload) : q.tasks.splice(0, q.tasks.length);
              var data = _map(tasks, function(task) {
                return task.data;
              });
              if (q.tasks.length === 0) {
                q.empty();
              }
              workers += 1;
              workersList.push(tasks[0]);
              var cb = only_once(_next(q, tasks));
              worker(data, cb);
            }
          },
          length: function() {
            return q.tasks.length;
          },
          running: function() {
            return workers;
          },
          workersList: function() {
            return workersList;
          },
          idle: function() {
            return q.tasks.length + workers === 0;
          },
          pause: function() {
            q.paused = true;
          },
          resume: function() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            var resumeCount = Math.min(q.concurrency, q.tasks.length);
            for (var w = 1; w <= resumeCount; w++) {
              async.setImmediate(q.process);
            }
          }
        };
        return q;
      }
      async.queue = function(worker, concurrency) {
        var q = _queue(function(items, cb) {
          worker(items[0], cb);
        }, concurrency, 1);
        return q;
      };
      async.priorityQueue = function(worker, concurrency) {
        function _compareTasks(a, b) {
          return a.priority - b.priority;
        }
        function _binarySearch(sequence, item, compare) {
          var beg = -1, end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + (end - beg + 1 >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        function _insert(q2, data, priority, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q2.started = true;
          if (!_isArray(data)) {
            data = [data];
          }
          if (data.length === 0) {
            return async.setImmediate(function() {
              q2.drain();
            });
          }
          _arrayEach(data, function(task) {
            var item = {
              data: task,
              priority,
              callback: typeof callback === "function" ? callback : noop
            };
            q2.tasks.splice(_binarySearch(q2.tasks, item, _compareTasks) + 1, 0, item);
            if (q2.tasks.length === q2.concurrency) {
              q2.saturated();
            }
            async.setImmediate(q2.process);
          });
        }
        var q = async.queue(worker, concurrency);
        q.push = function(data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        delete q.unshift;
        return q;
      };
      async.cargo = function(worker, payload) {
        return _queue(worker, 1, payload);
      };
      function _console_fn(name) {
        return _restParam(function(fn, args) {
          fn.apply(null, args.concat([_restParam(function(err, args2) {
            if (typeof console === "object") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                _arrayEach(args2, function(x) {
                  console[name](x);
                });
              }
            }
          })]));
        });
      }
      async.log = _console_fn("log");
      async.dir = _console_fn("dir");
      async.memoize = function(fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized2(args) {
          var callback = args.pop();
          var key = hasher.apply(null, args);
          if (has.call(memo, key)) {
            async.setImmediate(function() {
              callback.apply(null, memo[key]);
            });
          } else if (has.call(queues, key)) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            fn.apply(null, args.concat([_restParam(function(args2) {
              memo[key] = args2;
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i].apply(null, args2);
              }
            })]));
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      };
      async.unmemoize = function(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      };
      function _times(mapper) {
        return function(count, iterator, callback) {
          mapper(_range(count), iterator, callback);
        };
      }
      async.times = _times(async.map);
      async.timesSeries = _times(async.mapSeries);
      async.timesLimit = function(count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
      };
      async.seq = function() {
        var fns = arguments;
        return _restParam(function(args) {
          var that = this;
          var callback = args[args.length - 1];
          if (typeof callback == "function") {
            args.pop();
          } else {
            callback = noop;
          }
          async.reduce(
            fns,
            args,
            function(newargs, fn, cb) {
              fn.apply(that, newargs.concat([_restParam(function(err, nextargs) {
                cb(err, nextargs);
              })]));
            },
            function(err, results) {
              callback.apply(that, [err].concat(results));
            }
          );
        });
      };
      async.compose = function() {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
      };
      function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
          var go = _restParam(function(args2) {
            var that = this;
            var callback = args2.pop();
            return eachfn(
              fns,
              function(fn, _, cb) {
                fn.apply(that, args2.concat([cb]));
              },
              callback
            );
          });
          if (args.length) {
            return go.apply(this, args);
          } else {
            return go;
          }
        });
      }
      async.applyEach = _applyEach(async.eachOf);
      async.applyEachSeries = _applyEach(async.eachOfSeries);
      async.forever = function(fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
          if (err) {
            return done(err);
          }
          task(next);
        }
        next();
      };
      function ensureAsync(fn) {
        return _restParam(function(args) {
          var callback = args.pop();
          args.push(function() {
            var innerArgs = arguments;
            if (sync) {
              async.setImmediate(function() {
                callback.apply(null, innerArgs);
              });
            } else {
              callback.apply(null, innerArgs);
            }
          });
          var sync = true;
          fn.apply(this, args);
          sync = false;
        });
      }
      async.ensureAsync = ensureAsync;
      async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function(callback) {
          return callback.apply(this, args);
        };
      });
      async.wrapSync = async.asyncify = function asyncify(func) {
        return _restParam(function(args) {
          var callback = args.pop();
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (_isObject(result) && typeof result.then === "function") {
            result.then(function(value) {
              callback(null, value);
            })["catch"](function(err) {
              callback(err.message ? err : new Error(err));
            });
          } else {
            callback(null, result);
          }
        });
      };
      if (typeof module === "object" && module.exports) {
        module.exports = async;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return async;
        });
      } else {
        root.async = async;
      }
    })();
  }
});

// node_modules/mongoose-slug-generator/lib/slug-generator.js
var require_slug_generator = __commonJS({
  "node_modules/mongoose-slug-generator/lib/slug-generator.js"(exports, module) {
    "use strict";
    var getSlug = require_speakingurl2();
    var shortId = require_shortid();
    var async = require_async();
    module.exports = function(schema, options) {
      var watcher = [], slugs = [], opts = {
        separator: "-",
        lang: "en",
        truncate: 120
      };
      for (var attrname in options) {
        opts[attrname] = options[attrname];
      }
      schema.eachPath(function(pathname, schemaType) {
        if (schemaType.instance == "String" && schemaType.options && schemaType.options.slug) {
          var slug = {
            "name": pathname
          };
          if (typeof schemaType.options.slug === "string") {
            slug.values = [schemaType.options.slug];
          } else if (schemaType.options.slug instanceof Array) {
            slug.values = schemaType.options.slug;
          } else {
          }
          if (schemaType.options.unique || schemaType.options.unique_slug) {
            slug.unique = true;
          }
          if (schemaType.options.slug_padding_size === void 0) {
            slug.isShortIdMode = true;
          } else {
            slug.isShortIdMode = false;
            slug.padding = schemaType.options.slug_padding_size;
          }
          watcher = watcher.concat(slug.values.filter(function(item) {
            return watcher.indexOf(item) < 0;
          }));
          slugs.push(slug);
        }
      });
      schema.pre("save", function(next) {
        var doc = this, reSlug = false;
        watcher.forEach(function(item) {
          if (doc.isModified(item)) {
            reSlug = true;
          }
        });
        if (!reSlug) {
          return next();
        }
        async.each(slugs, function(item, callback) {
          var values = [];
          item.values.forEach(function(item2) {
            values.push(doc[item2]);
          });
          if (!(item.unique || item.unique_slug)) {
            doc[item.name] = makeSlug(values, opts);
            callback();
          } else {
            if (item.isShortIdMode) {
              makeUniqueShortIdSlug(doc, item.name, values, opts, function(err, slug) {
                doc[item.name] = slug;
                callback();
              });
            } else {
              makeUniqueCounterSlug(doc, item.name, values, opts, item.padding, function(err, slug) {
                doc[item.name] = slug;
                callback();
              });
            }
          }
        }, function(err, res) {
          next();
        });
      });
    };
    function makeSlug(values, options) {
      var slug = getSlug(
        values.join(" "),
        options
      );
      return slug;
    }
    function makeUniqueCounterSlug(doc, field, values, options, padding, next) {
      var slug = makeSlug(values, options), count = 0, match = null, test = new RegExp(options.separator + "(\\d+)$"), query = {}, search = new RegExp(slug + "(" + options.separator + "(\\d+))?$"), sort = {};
      sort[field] = -1;
      if (doc._id) {
        query["_id"] = {
          $ne: doc._id
        };
      }
      query[field] = search;
      doc.model(doc.constructor.modelName).findOne(query).sort(sort).exec(function(err, result) {
        if (result) {
          if (match = result[field].match(test)) {
            count = match[1];
          }
          count++;
          slug += options.separator + pad(count, padding);
        }
        next(null, slug);
      });
    }
    function pad(num, size) {
      var s = num + "";
      while (s.length < size)
        s = "0" + s;
      return s;
    }
    function makeUniqueShortIdSlug(doc, field, values, options, next) {
      var slug = makeSlug(values, options), query = {};
      query[field] = slug;
      doc.model(doc.constructor.modelName).findOne(query).exec(function(err, result) {
        if (result) {
          slug += options.separator + shortId.generate();
        }
        next(null, slug);
      });
    }
  }
});

// node_modules/mongoose-slug-generator/index.js
var require_mongoose_slug_generator = __commonJS({
  "node_modules/mongoose-slug-generator/index.js"(exports, module) {
    module.exports = require_slug_generator();
  }
});
export default require_mongoose_slug_generator();
/*! Bundled license information:

async/lib/async.js:
  (*!
   * async
   * https://github.com/caolan/async
   *
   * Copyright 2010-2014 Caolan McMahon
   * Released under the MIT license
   *)
*/
//# sourceMappingURL=mongoose-slug-generator.js.map
